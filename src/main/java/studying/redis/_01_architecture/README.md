# NoSQL과 Redis 스터디

## 1. NoSQL이란?

**NoSQL**은 **Not Only SQL** 또는 **No SQL**을 의미하며, SQL 을 사용하지 않는 데이터 저장소이다.

### 주요 특징

- **실시간 응답** - 빠른 데이터 처리 속도
- **확장성** - 수평적 확장 용이
- **고가용성** - 안정적인 서비스 제공
- **클라우드 네이티브** - 클라우드 환경 최적화
- **단순성** - 복잡한 조인 없이 간단한 구조
- **유연성** - 스키마가 없는 자유로운 데이터 모델링

크기와 구조를 예측할 수 없는 **비정형 데이터**와 **깊은 계층 구조를 가진 데이터**(JSON)를 다루는데 적합하다.

### NoSQL 유형

| 유형      | 설명                         | 예시                               |
|---------|----------------------------|----------------------------------|
| **키-값** | 키를 통해 데이터에 접근하는 가장 단순한 구조  | DynamoDB, ElastiCache, Memcached |
| **문서**  | JSON 형태의 계층적 트리 구조로 데이터 저장 | MongoDB, DocumentDB              |
| **칼럼**  | 칼럼 기반으로 데이터를 저장하고 처리       | Cassandra, HBase                 |
| **그래프** | 노드와 엣지로 관계를 표현             |                                  |

---

## 2. Redis란?

**Redis**는 **Remote Dictionary Server**의 약자로, 고성능 **key-value 구조**의 **인메모리 NoSQL** 데이터베이스다.

| 유형        | 단점                                                                 |
|-----------|--------------------------------------------------------------------|
| **레디스**   | 1. SQL 처럼 표현력이 뛰어난 수단이 없음<br/> 2. 일부 트랜잭션 기능을 지원하지 않음<br/>3. 비용이 큼 | 
| **RDBMS** | 1. 속도가 충분하지 않을 수 있음<br/>2. 일부 데이터 모델을 표현하려면 구현이 복잡해질 수 있음          |

### 주요 특징

#### 실시간 응답 (빠른 성능)

- **인메모리** 기반으로 디스크 접근 없이 데이터 처리 속도가 빠름

#### 단순성

- 다양한 데이터 구조 지원: String, Hash, List, Set, Sorted Set, Stream
- 이벤트 루프를 이용한 **싱글 스레드** 기반 동작 (메인 스레드 1개 + 보조 스레드 3개)
  - 루아 스크립트를 통해 여러 개의 레디스 명령어를 한번에 수행 가능 (한 번에 수행이지만 롤백은 없음)

#### 고가용성

- **복제(Replication)** 기능으로 여러 서버에 데이터 분산
- **Redis Sentinel**을 통한 자동 장애 조치(Failover)
- 마스터 장애 시 레디스로의 엔드포인트 변경 없이 장애 복구

#### 확장성

- **Redis Cluster** 모드를 통한 수평적 확장
- 클러스터 버스 프로토콜로 노드 간 통신 및 상태 관리

#### 클라우드 네이티브

- 멀티 클라우드 환경 지원
- 다양한 클라우드 서비스와 통합

### 도입 시점

- RDBMS에서 처리 성능(특히 쓰기 처리)의 병목 현상을 해결할 방법이 필요한 경우
  - ACID 트랜잭션 보장을 위한 WAL(Write-Ahead Logging) 오버헤드
  - 인덱스 업데이트와 잠금(Lock) 경합으로 인한 성능 저하
> RDBMS에서 여러 테이블을 조인한 결과가 여러번 사용되는 경우에는 레디스 캐싱을 통해 빠른 속도 기대 가능

---

## 3. MSA와 Redis

### 데이터 저장소로서의 Redis

Redis는 **영속성(Persistence)**을 위해 두 가지 방식을 제공합니다:

- **RDB (Redis Database)**: 특정 시점의 스냅샷을 바이너리 파일로 저장
- **AOF (Append Only File)**: 모든 쓰기 명령을 로그 파일에 순차적으로 기록

### 메시지 브로커로서의 Redis

메시징 큐 또는 stream 과 같은 메시지 브로커를 이용해 서비스들 간에 비동기적으로 데이터를 전달할 수 있는 통신 채널 구현 가능

#### 1. Pub/Sub (발행/구독)

Publisher → Channel → Multiple Subscribers

- 하나의 채널에 메시지를 발행하면, 해당 채널을 구독하는 모든 소비자가 실시간으로 메시지를 수신
- **일회성** 메시지로 전달 후 즉시 삭제

#### 2. List를 활용한 메시징 큐

Producer → [LPUSH] List [RPOP] → Consumer

- `LPUSH`/`RPUSH`로 메시지 추가, `LPOP`/`RPOP`로 메시지 소비
- **블로킹 기능** (`BLPOP`, `BRPOP`)으로 메시지 대기 및 즉시 처리

#### 3. Stream (스트림)

Producer → Stream → Consumer Group → Multiple Consumers

- Apache Kafka에서 영감을 받아 만들어진 자료 구조
- **Append-Only** 방식으로 데이터(메시지)가 계속 누적
- 카프카처럼 데이터를 읽을 수 있는 **Consumer**, **Consumer Group** 존재
- 저장된 데이터를 시간대별로 검색하는 것도 가능

---

## 참고 문헌

- **실전 레디스** by 하야시 쇼고
    - CHAPTER_01_레디스의 시작
- **개발자를 위한 레디스 (Redis for Developers)** by 김가림
    - CHAPTER_01_마이크로서비스 아키텍처와 레디스


